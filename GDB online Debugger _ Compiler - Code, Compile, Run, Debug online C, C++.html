import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;


public class shop{
    //create unchangable fields for recipt calculations (immutability)
    //static means it belongs to class and final means it cant be reassigned
    private static final double defaultTax = 0.1125;
    private static final double shippingByKG = 2.0;
    
    public static void main(String[] args){
        Scanner scnr = new Scanner(System.in);
        //
        List <Product> products = createProducts();
        //prompt user for a budget
        System.out.print("Show products below $");
        double budget = scnr.nextInt();
        scnr.nextLine();
        //create list of Products implementing runtime polymorphim-> p.costToShip
        //parent returns list including different subclasses
        List<Product> filtered = products.stream()
        .filter(p->p.getPrice() < budget)
        .sorted(Comparator.comparingDouble(Product::getPrice))
        .toList();

        //link each product to an ID number users will choose from
        Map<Integer, Product> ProductID = mapProds(filtered);
         //print all available items according to its product id
        printProductID(ProductID);
        //create cart
        Cart cart = new Cart(defaultTax, shippingByKG);
        System.out.print("\nWhich item(s) would you like to add? \n'remove' to remove or 'done' to move complete order\n");
        //scan to add/remove products until done-> move to receipt
        while(true){
        String selectItemID = scnr.nextLine();
        if(selectItemID.equals("done")){
            break;
        }
        if (selectItemID.equals("remove")){
            System.out.print("Which item would you like to remove? ");
            int remove = scnr.nextInt();
            scnr.nextLine();
            Product p = ProductID.get(remove);
                
            boolean changed = (p != null) && cart.subtractOne(p);
            if(changed) {
                System.out.println("Removed 1 " + p.getName());
            }
        }
        else {
            int id = Integer.parseInt(selectItemID);
            Product p = ProductID.get(id);
            if (p!=null){
                cart.addProduct(p);
                System.out.println("Added 1 " + p.getName() + "  to cart");
            }
        }
        
        if(!cart.getitems().isEmpty()){
            System.out.println("Cart contains: ");
            //return cart items
            cart.getitems().stream()
            .map(ci->ci.getProduct().getName() + " x" + ci.getQuantity())
            .forEach(System.out::println);
        }
        }
        System.out.println("\n Customer Receipt \n" + cart.makeReceipt());
    }
    

    
    //take products within budget and assign it an id 
    private static Map<Integer, Product> mapProds(List<Product>filtered){
        return IntStream.range(0, filtered.size())
        .boxed()
        .collect(Collectors.toMap(
            i-> i+1,
            filtered::get,
            (a,b)->a,
            LinkedHashMap::new
            ));
    }
    //print products in the given budget
    private static void printProductID(Map<Integer, Product> ProductID){
        System.out.println("\nProducts in your budget: ");
        //go through each product to get info and print
        ProductID.entrySet().stream()
        .map(entry->{
            int id =entry.getKey();
            Product p = entry.getValue();
            String type = (p instanceof PhysicalProduct)
            ? String.format("(%.2f kg)", ((PhysicalProduct) p).getWeightKg())
            :"digital";
            return String.format("%d) %-28s %7s %s%n",
            id, p.getName(), Cart.format(p.getPrice()), type);
        })
            .forEach(System.out::print);
    }   

    //define all products in shop
    private static List<Product> createProducts(){
        return List.of(
            new DigitalProduct("Digital1", "Students vs College - Digital", 19.00), 
            new DigitalProduct("Digital2", "Programming Languages (PDF) - Digital", 39.00), 
            new DigitalProduct("Digital3", "Architecture eBook (used) - Digital", 24.00), 
            new DigitalProduct("Digital4", "Minigame Mania - Digital", 20.00), 
            
            new PhysicalProduct("Physical1", "Uno - Physical", 10.00, 0.18),
            new PhysicalProduct("Physical2", "Black Jack - Physical", 21.00, 0.40),
            new PhysicalProduct("Physical3", "Connect 4 - Physical", 14.00, 0.65),
            new PhysicalProduct("Physical4", "Hello Kitty duck - Physical", 7.50, 0.60),
            new PhysicalProduct("Physical5", "3D printer - Physical", 300.00, 1.55),
            new PhysicalProduct("Physical6", "Chinchilla - Physical", 0.99, 0.20)
            );
    }
}
//define variables and functions that its subclasses will call onto
abstract class Product{
    //encapsulated data
    private String id;
    private String name;
    private double price;
    //subclasses call on this to create products ensureing all variabales are valid
    protected Product(String id, String name, double price){
        this.id = Objects.requireNonNull(id);
        this.name = Objects.requireNonNull(name);
        this.price = price;
    
    }
    //getters and setters read protected data and update it 
    //->other parts of the program cant modify this
    public String getId(){
        return id;
    }
    public String getName(){
        return name;
    }
    public double getPrice(){
        return price;
    }
    public void setName(String n) {
        this.name = Objects.requireNonNull(n);
    }
    public void setPrice(double p){
        this.price = p;
    }
    
    public abstract double costToShip(int quantity, double rateByKg);
}
//inherits from products and calls on methods to calculate 
class DigitalProduct extends Product{
    public DigitalProduct(String id, String name, double price){
        //super connects to Product to pass info 
        super(id, name, price);
    }
    //set its own shipping cost 
    @Override
    public double costToShip(int quantity, double rateByKg){
        return 0.0;
    }
}
//inherits from products, add weight then calls on methods to calculate
class PhysicalProduct extends Product{
    private double weightKg;
    
    public PhysicalProduct(String id, String name, double price, double weightKg){
        //super connects to Product to pass info
        super(id, name, price);
        this.weightKg= weightKg;
    }
    //create setter/getter for new variable
    public double getWeightKg(){
        return weightKg;
    }
    public void setWeightKg(double w){
        this.weightKg = w;
    }
    //set its own shipping cost 
    @Override
    public double costToShip(int quantity, double rateByKg){
        return weightKg * rateByKg * quantity;
    }
}
//calculate tax, shipping and total from items in cart-> puts into a receipt
class Cart {
    //create a list to carry all unchangeable data like tax and shipping cost
    private final List<CartItem> items = new ArrayList<>();
    private final double tax;
    private final double shipByWeight;
    //instructor initializing variables
    public Cart(double tax, double shipByWeight){
        this.tax = tax;
        this.shipByWeight = shipByWeight;
    }
    //returns an unchangeable list of items in cart (encapsulation)
    public List<CartItem> getitems(){
        return Collections.unmodifiableList(items);
    }
    //add products using overloading 
    public void addProduct(Product p){
        addProduct(p, 1);
    }
    //increace the quantity of a product in a cart
    public void addProduct(Product p, int quantity){
        CartItem existing = find(p.getId());
        if(existing == null) items.add(new CartItem(p, quantity));
        else existing.setQuantity(existing.getQuantity() + quantity);
    }
    //remove one item from cart 
    public boolean subtractOne(Product p){
        CartItem existing = find(p.getId());
        if (existing == null) {
        return false;
    }
        int q = existing.getQuantity();
        if(q>1) existing.setQuantity(q - 1);
        else items.remove(existing);
        return true;
    }
    //search by id
    private CartItem find(String ProductID){
        for (CartItem ci : items){
        if (ci.getProduct().getId().equals(ProductID)){
        return ci;
    }
        }
    return null;
    }
    //calculations
    public double total(){
        return items.stream()
        .map(CartItem::subtotal)
        .reduce(0.0, Double::sum);
    }
    public double shippingCost(){
        return items.stream()
        .map(ci->ci.shipping(shipByWeight))
        .reduce(0.0, Double::sum);
    }
    public double Tax() {
        return calculateTax(total(), tax);
    }
    public double totalWithTax(){
        return total() + shippingCost() + Tax();
    }
    public String makeReceipt(){
        StringBuilder sb = new StringBuilder();
        sb.append("Receipt:\n");
        //functional-style->cartItem joins into a line and then puts it in one string
        String line = items.stream()
        .map(ci ->String.format("%-8s %s x%d%n",
            format(ci.subtotal()), 
            ci.getProduct().getName(),
            ci.getQuantity()))
            .collect(Collectors.joining());
            sb.append(line);
        //receipt layout
        sb.append(String.format("%n%-12s %10s%n", "Subtotal: ", format(total())));
        sb.append(String.format("%-12s %10s%n", "Shipping: ", format(shippingCost())));
        sb.append(String.format("%-12s %10s%n", "Tax:", format(Tax())));
        sb.append(String.format("%-12s %10s%n", "Total: ", format(totalWithTax())));

        return sb.toString();
        
    }                 
    //pure methods(format, calculate, round)->
    //they dont alter data, just use it to return calculation
    public static String format(double amount){
        return String.format("$%.2f", round(amount));
    }
    public static double calculateTax(double total, double Tax){
        return round(total*Tax);
    }
    private static double round(double r){
        return Math.round(r*100.00)/100.00;
    }
    static class CartItem{
        //reference superclass Product
        private final Product product;
        private int quantity;
        //items hiddin within cart
        CartItem(Product product, int quantity){

            this.product = Objects.requireNonNull(product);
            this.quantity = quantity;
        }
        //getters and setters
        Product getProduct(){
            return product;
        }
        int getQuantity(){
            return quantity;
        }
        void setQuantity(int quan){
            this.quantity = quan;
        }
        double subtotal(){
            return product.getPrice() * quantity;
        }
        //will call depending on the subclass
        double shipping(double rateByKg){
            return product.costToShip(quantity, rateByKg);
        }
    }
}

    
